---
description: Frontend React/TypeScript development rules
globs: frontend/**
alwaysApply: false
---

# Frontend Development Conventions

## Architecture Principles

### Component Hierarchy
```
App.tsx (Router Setup)
├── NewUILayout (Overall Layout with <Outlet />)
    └── Pages (React Router driven - route-level containers)
        └── Business Components (Domain-specific features)
            └── UI Components (Reusable, domain-agnostic)
```

### Layer Responsibilities
1. **Layout**: `NewUILayout` provides app shell with navigation and `<Outlet />` for router content
2. **Pages**: Route-level containers that compose business components, follow `{Feature}Page.tsx` naming
3. **Business Components**: Domain-specific, can use domain terminology, not reusable across domains
4. **UI Components**: Domain-agnostic, reusable, no business terminology, composable only with other UI components

## File Structure
- frontend/src/components/ - OLD components (no new files)
- frontend/src/new-ui/ - NEW modern UI components
  - new-ui/layouts/ - App-level layouts (NewUILayout)
  - new-ui/pages/ - Route-level page components (AccountsPage, TransactionsPage, etc.)
  - new-ui/components/
    - business/ - Domain-specific components organized by domain
      - accounts/ - Account management components
      - transactions/ - Transaction-related components  
      - categories/ - Category management components
      - fzip/ - Backup/restore components
    - ui/ - Reusable, domain-agnostic components
  - new-ui/hooks/ - Custom React hooks
  - new-ui/styles/ - Global styles/themes
  - new-ui/utils/ - UI-specific utility functions
  - new-ui/views/ - Complex view components (higher-level than pages)
- frontend/src/services/ - API clients and external service integrations
  - Service classes for backend API communication
  - Authentication service, account service, transaction service, etc.
  - HTTP client configuration and error handling
  - Service layer abstracts API details from components
- frontend/src/types/ - TypeScript type definitions
  - Domain model types (Account, Transaction, Category, etc.)
  - API response/request types
  - Component prop types
  - Utility types and type guards
- frontend/src/schemas/ - Zod validation schemas
  - Input validation schemas for forms
  - API response validation schemas
  - Data transformation and parsing schemas
  - Corresponds to backend models for consistency
- frontend/src/stores/ - State management (Zustand stores)
  - Global application state
  - Domain-specific stores (transactionsStore, etc.)
  - State persistence and hydration logic
- frontend/src/utils/ - General utility functions
  - Date formatting, currency formatting
  - Data transformation helpers
  - Common validation functions
  - Pure functions with no side effects
- frontend/src/hooks/ - Global custom React hooks (if any)
  - Cross-domain hooks that don't fit in new-ui/hooks/
  - Prefer domain-specific hooks in new-ui/hooks/ when possible

## Component Rules

### Business Components
- Located in `new-ui/components/business/{domain}/`
- Can use domain-specific terminology (Account, Transaction, Category, etc.)
- Not reusable across different business domains
- Can compose other business components from same domain OR ui components
- Should handle domain-specific logic and state

### UI Components  
- Located in `new-ui/components/ui/`
- Must be domain-agnostic (no business terminology)
- Reusable across the entire application
- Can only compose other UI components
- Should be pure presentation components with minimal logic
- Examples: Button, DateCell, CurrencyDisplay, StatusBadge

### Pages
- Located in `new-ui/pages/`
- Follow `{Feature}Page.tsx` naming convention (AccountsPage, TransactionsPage, etc.)
- Should be thin containers that primarily compose business components
- Handle routing-level concerns and page-level state
- Minimal direct UI logic - delegate to business components
- Directly referenced by React Router routes

## Testing
- Run tests via frontend/fe_unit_tests.sh
- Jest configuration in jest.config.mjs
- Test files in __tests__/ directories
- Mock external dependencies appropriately

## Services and Data Layer

### Services (frontend/src/services/)
- Service classes handle all backend API communication
- Each domain should have its own service (AccountService, TransactionService, etc.)
- Services should abstract API details from components
- Include proper error handling and HTTP client configuration
- Services return typed data using types from frontend/src/types/

### Types (frontend/src/types/)
- Define TypeScript interfaces for all domain models
- Include API request/response types
- Component prop types for complex props
- Use utility types and type guards for type safety
- Keep types consistent with backend models

### Schemas (frontend/src/schemas/)
- Zod schemas for runtime validation
- Validate form inputs and API responses
- Transform and parse data consistently
- Should correspond to backend Pydantic models
- Use for type-safe data validation throughout the app

### State Management (frontend/src/stores/)
- Use Zustand for global state management
- Create domain-specific stores (transactionsStore, accountsStore, etc.)
- Handle state persistence and hydration
- Keep stores focused on specific domains
- Use TypeScript for store typing
- **See frontend-store-conventions.mdc for detailed Zustand patterns and best practices**

## Error Handling

### Zod Validation Errors
- Use `zodErrorHandler.ts` utility for consistent error processing
- Provide user-friendly error messages that avoid technical jargon
- Include clear console logging for debugging with full error context
- Transform Zod validation errors into actionable user feedback
- Log validation errors with structured data for troubleshooting
- Example pattern:
  ```typescript
  try {
    const result = schema.parse(data);
  } catch (error) {
    const userMessage = handleZodError(error);
    console.error('Validation failed:', { error, data, schema: schema._def });
    showUserError(userMessage);
  }
  ```

## UI Standards
- Follow modern UI design patterns
- Use the established theme system in new-ui/styles/
- Ensure responsive design
- Maintain consistent styling across new-ui components
- Each component should have its own CSS file when needed

## Import Ordering
- All imports must start with external libraries first, then internal imports
- Use consistent import grouping and ordering for maintainability
- Use path aliases for internal imports: `@/` maps to `src/` (configured in tsconfig.app.json)
- Example: `import { Button } from '@/new-ui/components/ui/Button'`

## Accessibility Rules
- Visible, non-interactive elements with click handlers must have at least one keyboard listener