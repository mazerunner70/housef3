"""
Lambda function for file map operations.
"""
import os
import json
import logging
import traceback
from typing import Dict, Any, List, Optional
import uuid
from botocore.exceptions import ClientError
from pydantic import ValidationError
from datetime import datetime, timezone

from models.file_map import FileMap, FileMapCreate, FileMapUpdate
from utils.db_utils import NotAuthorized, list_user_files
from utils.lambda_utils import create_response, handle_error, mandatory_path_parameter
from utils.auth import get_user_from_event
from utils.db_utils import (
    checked_mandatory_file_map,
    create_file_map,
    get_file_map,
    update_file_map,
    delete_file_map as delete_file_map_from_db,  # Renamed to avoid conflict
    list_file_maps_by_user,
    list_account_file_maps
)

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# --- DRY Utility Functions ---

def parse_and_validate_json(event: Dict[str, Any], model_class):
    """Parse JSON body and validate using Pydantic model."""
    body_str = event.get('body')
    if not body_str:
        return None, create_response(400, {"error": "Request body is missing or empty"})
    
    try:
        return model_class.model_validate_json(body_str), None
    except ValidationError as e:
        logger.error(f"Validation error: {str(e)}", exc_info=True)
        return None, create_response(400, {"error": "Invalid file map data", "details": e.errors()})
    except json.JSONDecodeError:
        logger.error("Invalid JSON format in request body")
        return None, create_response(400, {"error": "Invalid JSON format in request body"})

def serialize_file_map(file_map: FileMap) -> Dict[str, Any]:
    """Serialize a FileMap model to JSON-safe dict."""
    return file_map.model_dump(by_alias=True)

def serialize_file_map_list(file_maps: List[FileMap]) -> Dict[str, Any]:
    """Serialize a list of FileMap models to JSON-safe dict."""
    return {'fileMaps': [fm.model_dump(by_alias=True) for fm in file_maps]}

def create_file_map_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    Create a new file map.
    
    Args:
        event: API Gateway Lambda proxy event
        user: Authenticated user details
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        # Parse and validate JSON using utility function
        file_map_data_dto, error_response = parse_and_validate_json(event, FileMapCreate)
        if error_response:
            return error_response

        # At this point, file_map_data_dto is guaranteed to be valid (not None)
        assert file_map_data_dto is not None

        # Create a new FileMap instance using the validated DTO data and the user_id
        # file_map_id, created_at, updated_at will be auto-generated by FileMap model defaults
        new_file_map_instance = FileMap(
            userId=user_id, # Pass user_id directly
            **file_map_data_dto.model_dump() # Spread the validated DTO data
        )
        
        # Save to DynamoDB
        create_file_map(new_file_map_instance)
        
        # Return the created file map using utility function
        return create_response(201, serialize_file_map(new_file_map_instance))
        
    except ClientError as e:
        logger.error(f"DynamoDB error creating file map: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error creating file map: Database operation failed.")
    except Exception as e: # Catch any other unexpected errors
        logger.error(f"Unexpected error creating file map: {str(e)}", exc_info=True)
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, f"Error creating file map: {str(e)}")

def get_file_map_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    Get a file map by ID.
    
    Args:
        event: API Gateway Lambda proxy event
        user: Authenticated user details
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        file_map_id = event['pathParameters']['id']
        
        # Get the file map
        # response = get_file_maps_table().get_item(Key={'fileMapId': file_map_id})
        file_map = get_file_map(file_map_id)
        
        # if 'Item' not in response:
        if not file_map:
            return handle_error(404, f"File map {file_map_id} not found")
            
        # file_map = FileMap.model_validate(response['Item'])
        
        # Check ownership
        if str(file_map.user_id) != user_id:
            return handle_error(403, "Not authorized to access this file map")
            
        return create_response(200, serialize_file_map(file_map))
        
    except ClientError as e:
        logger.error(f"DynamoDB error getting file map: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error retrieving file map")

def list_file_maps_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    List file maps for a user, optionally filtered by account.
    
    Args:
        event: API Gateway Lambda proxy event
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        account_id = event.get('queryStringParameters', {}).get('accountId')
        
        if account_id:
            # Query by account using GSI
            # response = get_file_maps_table().query(
            #     IndexName='AccountIdIndex',
            #     KeyConditionExpression='accountId = :accountId',
            #     ExpressionAttributeValues={':accountId': account_id}
            # )
            file_maps_models = list_account_file_maps(account_id)
        else:
            # Query by user using GSI
            # response = get_file_maps_table().query(
            #     IndexName='UserIdIndex',
            #     KeyConditionExpression='userId = :userId',
            #     ExpressionAttributeValues={':userId': user_id}
            # )
            file_maps_models = list_file_maps_by_user(user_id)
            
        # Use model_validate for items from DB and model_dump for response
        # file_maps_models = [FileMap.model_validate(item) for item in response.get('Items', [])]
        
        # Filter out file maps not owned by the user (when querying by account)
        if account_id:
            file_maps_models = [fm for fm in file_maps_models if str(fm.user_id) == user_id]
            
        return create_response(200, serialize_file_map_list(file_maps_models))
        
    except ClientError as e:
        logger.error(f"DynamoDB error listing file maps: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error listing file maps")

def update_file_map_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    Update a file map.
    
    Args:
        event: API Gateway Lambda proxy event
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        file_map_id = uuid.UUID(mandatory_path_parameter(event, 'id'))
        
        # Get existing file map
        # response = get_file_maps_table().get_item(Key={'fileMapId': file_map_id})
        file_map = checked_mandatory_file_map(file_map_id, user_id)
        
            
        # Parse and validate JSON using utility function
        update_data_dto, error_response = parse_and_validate_json(event, FileMapUpdate)
        if error_response:
            return error_response

        if update_data_dto:
            # Use the model's update_with_data method to handle updates cleanly
            file_map.update_with_data(update_data_dto)
        
        # Save updates
        update_file_map(file_map)
        
        return create_response(200, serialize_file_map(file_map))
        
    except ClientError as e:
        logger.error(f"DynamoDB error updating file map: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error updating file map")

def delete_file_map_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    Delete a file map.
    
    Args:
        event: API Gateway Lambda proxy event
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        file_map_id = uuid.UUID(mandatory_path_parameter(event, 'id'))
        
        # Get the file map to check ownership
        # response = get_file_maps_table().get_item(Key={'fileMapId': file_map_id})
        file_map = checked_mandatory_file_map(file_map_id, user_id)

        # Check if the file map is associated with any files
        files = list_user_files(user_id)
        matching_file_names = [file.file_name for file in files if file.file_map_id == file_map_id]
        if matching_file_names:
            return handle_error(400, f"File map is associated with files and cannot be deleted: {', '.join(matching_file_names)}")

        # Delete the file map
        # get_file_maps_table().delete_item(Key={'fileMapId': file_map_id})
        delete_file_map_from_db(file_map_id)
        
        return create_response(204, {})
        
    except ClientError as e:
        logger.error(f"DynamoDB error deleting file map: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error deleting file map")
    except KeyError as e:
        logger.error(f"Invalid file map ID: {str(e)}")
        return handle_error(400, "Invalid file map ID")
    except NotAuthorized as e:
        logger.error(f"Not authorized to delete file map: {str(e)}")
        return handle_error(403, "Not authorized to delete this file map")
    except ValueError as e:
        logger.error(f"Invalid file map ID: {str(e)}")
        return handle_error(400, "Invalid file map ID")
    

def handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Main Lambda handler for file map operations.
    
    Args:
        event: API Gateway Lambda proxy event
        context: Lambda context
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        # Get user from Cognito
        user = get_user_from_event(event)
        if not user:
            return create_response(401, {"message": "Unauthorized"})
        user_id = user.get('id')
        if not user_id:
            return create_response(401, {"message": "Unauthorized"})
        # Get route from event
        route = event.get('routeKey')
        if not route:
            return create_response(400, {"message": "Route not specified"})
        
            # Log request details
                # Get the HTTP method and route
        method = event.get("requestContext", {}).get("http", {}).get("method", "").upper()
        logger.info(f"Request: {route}")

        # Route to appropriate handler
        if route == 'POST /file-maps':
            return create_file_map_handler(event, user_id)
        elif route == 'GET /file-maps/{id}':
            return get_file_map_handler(event, user_id)
        elif route == 'GET /file-maps':
            return list_file_maps_handler(event, user_id)
        elif route == 'PUT /file-maps/{id}':
            return update_file_map_handler(event, user_id)
        elif route == 'DELETE /file-maps/{id}':
            return delete_file_map_handler(event, user_id)
        else:
            return handle_error(404, f"Route {route} not found")
            
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Internal server error") 