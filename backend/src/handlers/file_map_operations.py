"""
Lambda function for file map operations.
"""
import os
import json
import logging
import traceback
from typing import Dict, Any, List, Optional
from botocore.exceptions import ClientError
from pydantic import ValidationError
from datetime import datetime, timezone

from models.file_map import FileMap, FileMapCreate, FileMapUpdate
from utils.lambda_utils import create_response, handle_error
from utils.auth import get_user_from_event
from utils.db_utils import (
    create_file_map,
    get_file_map,
    update_file_map,
    delete_file_map as delete_file_map_from_db,  # Renamed to avoid conflict
    list_file_maps_by_user,
    list_account_file_maps
)

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

def create_file_map_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    Create a new file map.
    
    Args:
        event: API Gateway Lambda proxy event
        user: Authenticated user details
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        body_str = event.get('body')
        if not body_str:
            return create_response(400, {"error": "Request body is missing or empty"})
        
        try:
            # Validate incoming data against FileMapCreate DTO
            file_map_data_dto = FileMapCreate.model_validate_json(body_str)
        except ValidationError as e:
            logger.error(f"Validation error creating file map: {str(e)}", exc_info=True)
            return create_response(400, {"error": "Invalid file map data", "details": e.errors()})
        except json.JSONDecodeError:
            logger.error("JSONDecodeError creating file map: Invalid JSON format")
            return create_response(400, {"error": "Invalid JSON format in request body"})

        # Create a new FileMap instance using the validated DTO data and the user_id
        # file_map_id, created_at, updated_at will be auto-generated by FileMap model defaults
        new_file_map_instance = FileMap(
            userId=user_id, # Pass user_id directly
            **file_map_data_dto.model_dump() # Spread the validated DTO data
        )
        
        # Save to DynamoDB using model_dump(by_alias=True) to respect field aliases
        # get_file_maps_table().put_item(Item=new_file_map_instance.model_dump(by_alias=True))
        create_file_map(new_file_map_instance)
        
        # Return the created file map, also respecting aliases
        return create_response(201, new_file_map_instance.model_dump(by_alias=True))
        
    except ClientError as e:
        logger.error(f"DynamoDB error creating file map: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error creating file map: Database operation failed.")
    except Exception as e: # Catch any other unexpected errors
        logger.error(f"Unexpected error creating file map: {str(e)}", exc_info=True)
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, f"Error creating file map: {str(e)}")

def get_file_map_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    Get a file map by ID.
    
    Args:
        event: API Gateway Lambda proxy event
        user: Authenticated user details
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        file_map_id = event['pathParameters']['id']
        
        # Get the file map
        # response = get_file_maps_table().get_item(Key={'fileMapId': file_map_id})
        file_map = get_file_map(file_map_id)
        
        # if 'Item' not in response:
        if not file_map:
            return handle_error(404, f"File map {file_map_id} not found")
            
        # file_map = FileMap.model_validate(response['Item'])
        
        # Check ownership
        if str(file_map.user_id) != user_id:
            return handle_error(403, "Not authorized to access this file map")
            
        return create_response(200, file_map.model_dump(by_alias=True))
        
    except ClientError as e:
        logger.error(f"DynamoDB error getting file map: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error retrieving file map")

def list_file_maps_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    List file maps for a user, optionally filtered by account.
    
    Args:
        event: API Gateway Lambda proxy event
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        account_id = event.get('queryStringParameters', {}).get('accountId')
        
        if account_id:
            # Query by account using GSI
            # response = get_file_maps_table().query(
            #     IndexName='AccountIdIndex',
            #     KeyConditionExpression='accountId = :accountId',
            #     ExpressionAttributeValues={':accountId': account_id}
            # )
            file_maps_models = list_account_file_maps(account_id)
        else:
            # Query by user using GSI
            # response = get_file_maps_table().query(
            #     IndexName='UserIdIndex',
            #     KeyConditionExpression='userId = :userId',
            #     ExpressionAttributeValues={':userId': user_id}
            # )
            file_maps_models = list_file_maps_by_user(user_id)
            
        # Use model_validate for items from DB and model_dump for response
        # file_maps_models = [FileMap.model_validate(item) for item in response.get('Items', [])]
        
        # Filter out file maps not owned by the user (when querying by account)
        if account_id:
            file_maps_models = [fm for fm in file_maps_models if str(fm.user_id) == user_id]
            
        return create_response(200, {'fileMaps': [fm.model_dump(by_alias=True) for fm in file_maps_models]})
        
    except ClientError as e:
        logger.error(f"DynamoDB error listing file maps: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error listing file maps")

def update_file_map_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    Update a file map.
    
    Args:
        event: API Gateway Lambda proxy event
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        file_map_id = event['pathParameters']['id']
        body = json.loads(event['body'])
        
        # Get existing file map
        # response = get_file_maps_table().get_item(Key={'fileMapId': file_map_id})
        file_map = get_file_map(file_map_id)
        
        # if 'Item' not in response:
        if not file_map:
            return handle_error(404, f"File map {file_map_id} not found")
            
        # file_map = FileMap.model_validate(response['Item'])
        
        # Check ownership
        if str(file_map.user_id) != user_id:
            return handle_error(403, "Not authorized to update this file map")
            
        # --- Logic for applying updates using FileMapUpdate DTO ---
        # This part needs to be refactored to use FileMapUpdate DTO
        # For now, keeping original update logic structure but using Pydantic models
        
        update_data_dto: Optional[FileMapUpdate] = None
        try:
            update_data_dto = FileMapUpdate.model_validate_json(event['body'])
        except ValidationError as e:
            logger.error(f"Validation error updating file map: {str(e)}", exc_info=True)
            return create_response(400, {"error": "Invalid file map update data", "details": e.errors()})
        except json.JSONDecodeError:
            logger.error("JSONDecodeError updating file map: Invalid JSON format")
            return create_response(400, {"error": "Invalid JSON format in request body"})

        if update_data_dto:
            update_dict = update_data_dto.model_dump(exclude_unset=True, by_alias=False) # Use field names for setattr
            changed = False
            for key, value in update_dict.items():
                if hasattr(file_map, key) and getattr(file_map, key) != value:
                    # Special handling for mappings field to ensure proper FieldMapping objects
                    if key == 'mappings' and value is not None:
                        # Convert dictionary mappings to FieldMapping objects
                        from models.file_map import FieldMapping
                        field_mappings = []
                        for mapping_dict in value:
                            if isinstance(mapping_dict, dict):
                                field_mappings.append(FieldMapping(**mapping_dict))
                            else:
                                field_mappings.append(mapping_dict)  # Already a FieldMapping object
                        setattr(file_map, key, field_mappings)
                    else:
                        setattr(file_map, key, value)
                    changed = True
            
            if changed:
                file_map.updated_at = int(datetime.now(timezone.utc).timestamp() * 1000) # Manually update timestamp
        
        # Save updates
        # get_file_maps_table().put_item(Item=file_map.model_dump(by_alias=True))
        update_file_map(file_map)
        
        return create_response(200, file_map.model_dump(by_alias=True))
        
    except (json.JSONDecodeError) as e: # ValueError removed as Pydantic handles it
        return handle_error(400, str(e))
    except ClientError as e:
        logger.error(f"DynamoDB error updating file map: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error updating file map")

def delete_file_map_handler(event: Dict[str, Any], user_id: str) -> Dict[str, Any]:
    """
    Delete a file map.
    
    Args:
        event: API Gateway Lambda proxy event
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        file_map_id = event['pathParameters']['id']
        
        # Get the file map to check ownership
        # response = get_file_maps_table().get_item(Key={'fileMapId': file_map_id})
        file_map = get_file_map(file_map_id)
        
        # if 'Item' not in response:
        if not file_map:
            return handle_error(404, f"File map {file_map_id} not found")
            
        # file_map = FileMap.model_validate(response['Item'])
        
        # Check ownership
        if str(file_map.user_id) != user_id:
            return handle_error(403, "Not authorized to delete this file map")
            
        # Delete the file map
        # get_file_maps_table().delete_item(Key={'fileMapId': file_map_id})
        delete_file_map_from_db(file_map_id)
        
        return create_response(204, {})
        
    except ClientError as e:
        logger.error(f"DynamoDB error deleting file map: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Error deleting file map")

def handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Main Lambda handler for file map operations.
    
    Args:
        event: API Gateway Lambda proxy event
        context: Lambda context
        
    Returns:
        API Gateway Lambda proxy response
    """
    try:
        # Get user from Cognito
        user = get_user_from_event(event)
        if not user:
            return create_response(401, {"message": "Unauthorized"})
        user_id = user.get('id')
        if not user_id:
            return create_response(401, {"message": "Unauthorized"})
        # Get route from event
        route = event.get('routeKey')
        if not route:
            return create_response(400, {"message": "Route not specified"})
        
            # Log request details
                # Get the HTTP method and route
        method = event.get("requestContext", {}).get("http", {}).get("method", "").upper()
        logger.info(f"Request: {method} {route}")

        # Route to appropriate handler
        if route == 'POST /file-maps':
            return create_file_map_handler(event, user_id)
        elif route == 'GET /file-maps/{id}':
            return get_file_map_handler(event, user_id)
        elif route == 'GET /file-maps':
            return list_file_maps_handler(event, user_id)
        elif route == 'PUT /file-maps/{id}':
            return update_file_map_handler(event, user_id)
        elif route == 'DELETE /file-maps/{id}':
            return delete_file_map_handler(event, user_id)
        else:
            return handle_error(404, f"Route {route} not found")
            
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        logger.error(f"stack trace: {traceback.format_exc()}")
        return handle_error(500, "Internal server error") 